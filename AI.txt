PEAS
====
- Partially observable  ->
- stochastic            -> User space can add a new processes and preempt the
                           current chosen one
- sequential            -> next action could change regarding how the previous
                           process influence the memory, cache, lock, ...
- dynamic               -> new processes added to the run queue
- discrete              -> finite set of possible state and action (not
                           represented by Real-number)
- multi-agent           -> one selecting next task, one migrating next task, one
                           selecting page to remove

-> Utility based agent
-> Reinforcement learning

4 agents:   1. Scheduling processes -> reduce average time
            2. Waking up processes  -> reduce context switch
            3. Migrating processes  -> reduce cache miss and running time
            4. Reclaiming page      -> reduce page fault

1. Scheduling processes
=======================
QUESTION: How to remember the utility of a process when deleted?
    - Modify the file descriptor to save the utility info
QUESTION: How to deal with the fact that a new process arrive with no knowledge?
    - Consider the Utility of its parent and average run-time
    - keep a tree of parent and child process in the program file to keep track
      of the utility or P(t|i) for Idea 2

When changing state?      -> when task preempted
What is the next action?  -> Choosing another task
What is a state?          -> state of the run-queue

/!\ process always change (added, removed) -> action and state always change
                                           -> infinite state space
                                           -> infinite action space
Idea 1:
-------
state space: current process
action space: one of the process in the run queue
Rewards: - page fault
         - Involuntary preemption (lock, task with high priority)
         - Involuntary wait-time  (lock, task with high priority)

Each process has a tree of the utility of each next process to run and chooses
the next one from its list

Idea 2:
-------
state space: number of quanta each task used s = (s1, ..., sn)
action space: one of the process in the run queue
rewards: sum for each task of time accorded to the task minus total time used
         multiply by the quantity of resources attributed

         R(s) = sum(i, |si - T(s) * ui|)

the action is chosen regarding the process that has the most utility and the
highest probability to run for a long time.

state infinity -> always new state

Possible to determine cost of each state
utilization target -> how much resource should be allocated to a task
utilization ray -> how the scheduler should schedule the task to have the optimal
                   scheduler. When utilization ray = utilization state -> no cost
                   try to follow utilization ray
Create repeated state when each utilization ray is passed:
    .       . 2
    .       .   /   .       -> dot 1 and 2 the same because same cost
    . 1     .       .
    .   /   .       .

Problem -> no V(s) -> Use function approximation to learn from previous process
                      based on run time, involuntary preemption, memory,
                      I/O bound, ...
                      Or Will get the same utility than its parent

transition state represents probability that process will run t time because
could be preempt or voluntary switch or ...

Utilization target -> how should normally distributed the CPU time per processes

transition state P(s'|s, a) = P(t|i) depends on probability of the process to run
t time, not on current state -> change it using vruntime or  average run-time

when process waiting, keep it in the list of AI to put the probability.

Inspired by BFS:
now - vdeadline = W -> the time the process should finish

always taske 10 processes and schedule them, learn the utility between them
and then take the 10 next and always shift with the round robin

Idea 3:
-------
Create pool of type of process based on:

              bit 2       |        bit 1       |            bit 0
    class = I/O-CPU bound | kernel-user thread | independent-cooperative process

    -> must determine I/O-CPU bound and independent-cooperative process during
       process run-time

    -> TODO: How to determine before running ???

state space:

action space:
-

Rewards:

Idea 4:
-------
use the idea of calculation vruntime = w1 * delta_exec + w2 * weight_load
and learn w1 and w2

NOTE: It would assume that all the process act the same

2. Migrating processes
======================
When changing state?      -> when task preempted or affinity ticks
What is the next action?  -> Choosing if task should be migrated on another Core
What is a state?          -> state of load balance of the CPU and task affinity

QUESTION: Should the scheduling domains be kept?
QUESTION: How to predict how good is going to be a process on another core?

Try to be as less as possible to use cache miss and IPC

Idea 1:
-------
state space:  s = (s CPU 1, s CPU 2, ..., s current process with no affinity)
NOTE: if CPU overload, maybe not the best to move the current process

-> define level of affinity
-> define level of load
=> learn the utility of each state
=> state space size = nbr_load_state ^ nbr_cpu * nbr_affinity_state

s CPU calculated based on: - load = nbr process in Runqueue * avg runtime
                           - CPU s = load_i / sum(i, load_i)

s current affinity: - cache affinity (higher priority bigger cache affinity)
                    - (avg) page-fault
                    - (avg) runtime
                    - (avg) cache miss  -> cache affinity
                    - IPC               -> runtime (not consider nbr cache miss)
                    - memory space      -> impossible to determine
                    - nbr involuntary context switch
                    - executed during a certain interval -> defined by runtime

/!\ cache miss doesn't influence process' runtime

action space: move task i on CPU y

- nbr time scheduled
- nbr time blocked
- ...

Utility:

Rewards:
-> difference between load added to new CPU and load removed of the previous
   CPU
-> difference between IPC in new CPU and old CPU
-> Define a number of execution of the process and then compare the rate measured
   to determine the state of the process and the rewards -> trigger_load_balance()

3. Waking up processes
======================


4. Reclaiming page
==================
When changing state?      -> when page accessed, swapped, ...
What is the next action?  -> Choosing if a page should be in active or inactive
                             list
What is a state?          -> state of RAM, if too many page

QUESTION: How to remember the utility of a page?
    - If always same page, the utility can be saved with the page

/!\ Their is a huge amount of pages in the cache

utility of the page
number of page that should be removed
swap tendency to know how much user page should be removed

Idea 1:
-------
state: per page, utility to be in inactive or active queue
NOTE: if all the pages have a utility to be in active queue

Idea 2:
-------
state: per page cache, sorted queue of page utility
NOTE: Would take a lot of time to resort the queue
NOTE: Create 2 queue:
    -> inactive: tail = last one inserted, head = max utility of the queue
    -> active: tail = min utility of the queue, head = last inserted

    How many pages should be in active and inactive queue ???
    How to judge the utility limit if no process in inactive queue ???
    How to have a rewards correct as the utility is in relation of the other,
    not in relation with the page ???

Idea 3:
-------
state: the page cache, the page present and the number of page to remove
action: keep or remove the page from the page cache
utility: - nbr page to reclaim      less tolerant
         - nbr page in cache,       more tolerant
         - scan control priority

         - avg time between each page access
         - if referenced or accessed recently
         - nbr of process accessing it
