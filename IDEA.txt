Be focus on:
	- Scheduler
	- Lock and synchronization system
	- Memory Management, Paging and virtual memory

	- load balance
	- scheduler
	- lock

Q-learning for each process
then put the value in a neural network and select the new one

one agent on core to decide which process to run
one agent to dispatch element between cores

--------------------------------------------------------------------------------------------
- learn best timeslice
- use bitslice as matix to determine the next process
- learn best dynamic priority
- learn if I/O or processor bound process -> use sleep time
- use linux sleep time and running time average
- control balance between processor

 system call:
	sched_setscheduler()	Sets a process's scheduling policy
	sched_getscheduler()	Gets a process's scheduling policy

- average time of waiting to know if spinlock or wainting queue regarding context switch time
- use probability of using a page to know if possible to swap in or swap out
- how to handle block I/O search -> I/O scheduler
- VMA operation -> nopage()
- modify address space operation
- add list of potential process in lock struct
- use average of switch regarding running time
- Modifier the priority value given to CFS regarding attribute learned
- linux use 2 queue. after running one queue, calculate the order of the new one
- Markov decision process with permutation tree
- Q-learning -> each process -> action / each state -> sleeping or waiting
	-> DQN, each process = one neurone of fully connected layer
	-> one page for the state space
always used red-black tree to order the max
or list where first always max and directly compared with
- learn memory map for numa architecture
- no relation with lock for distpach around the different CPU
- one state is the core
