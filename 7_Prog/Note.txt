Installation:
=============

diff -uNr linux-4.17.2/  AI-linux/ > ai-linux.patch
tar -jcf ai-linux-patch.tar.bz2 ai-linux.patch

tar -xf ai-linux-patch.tar.bz2 ai-linux.patch
cd /path/to/Linux/kernel
patch -Np1 -i /path/to/the/patch/ai-linux.patch

yum install "Development Tools" "Development Libraries"
yum install elfutils-libelf-devel
make menuconfig
make
make modules_install
make modules

virtualization:
===============
Ubuntu:
mkinitramfs -o initrd-4.17.2.img
qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage -initrd \
initrd-4.17.2.img -m 512M -nographic -append 'console=ttyS0' -serial mon:stdio

Fedora:
dracut -o initrd-4.17.2.img
qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage -initrd \
initrd-4.17.2.img -m 512M -nographic -append 'console=ttyS0' -serial mon:stdio

From USB:
sudo qemu-system-x86_64 -enable-kvm -m 1024 -usb /dev/<device>

NOTE: if impossible to run server:
        xhost +
        dbus-update-activation-environment --systemd DBUS_SESSION_BUS_ADDRESS DISPLAY XAUTHORITY



--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
https://www.slideshare.net/shimosawa/linux-initialization-process-2
https://elixir.bootlin.com/linux/v4.17.2/ident
https://books.google.co.uk/books?id=uxhKDwAAQBAJ&pg=PA240&lpg=PA240&dq=linux+how+kernel+mutex+push+task+to+sleep&source=bl&ots=GFPzx6_c0J&sig=NraggxWPYnDpMZbtAMqWYn129ug&hl=en&sa=X&ved=0ahUKEwivkOfTgu_bAhVFCuwKHTZUC4QQ6AEIPjAB#v=onepage&q=linux%20how%20kernel%20mutex%20push%20task%20to%20sleep&f=false


Used Kernel version: 4.17.2

task priority == load.weight
task runtime  == sched.avg.runnable_avg_period
task load avg == sched.avg.load_avg_contrib

Scheduler:
----------
https://www.embedded.com/design/operating-systems/4204929/Real-Time-Linux-Scheduling-Part-1
https://www.embedded.com/design/operating-systems/4204971/Real-Time-Linux-Scheduling-Part-2
https://www.embedded.com/design/operating-systems/4204980/Real-Time-Linux-Scheduling-Part-3

Priority: RT -> CFS -> IDLE, changed to RT -> myScheduler -> IDLE

- Folder kernel/sched
- Actually core.c, sched.h, fair.c
- Replace fair.c -> myScheduler.c

1. Must implement the scheduler throught: struct sched_class -> sched.h line 1463
2. Create the functions for sched_class, use fair.c
3. Add the scheduler policy with __setscheduler()
4. don't forget to add the file into Makefile obj.y += myScheduler.o
5. define the selection of the scheduler in init/kConfig
        -> with setting for the constant factor

CPU Controller -> CONFIG_FAIR_GROUP_SCHED => init/kConfig

- SFS (smartly fair scheduler) CONFIG_SCHED_SFS
- smart.c

scheduler_tick() core.c
        -> task_tick() struct sched_class
                -> get run queue cfs_rq of each entity
                -> entity_tick() fair.c for each entity_sched  ==   Core
                        -> update_curr(cfs_rq); fair.c
                                -> update_min_vruntime() fair.c re-order the red-black tree
                        -> update_load_avg(cfs_rq, curr, UPDATE_TG); fair.c  use with load balance, Update task and its cfs_rq load average
                        -> update_cfs_group(curr);                   fair.c  I DON'T KNOW ????

struct task_struct sched.h

schedule() core.c
        -> __schedule() core.c
                -> pick_next_task()
                        -> fair_sched_class.pick_next_task()
                                -> pick_next_task_fair()

scheduler_tick each Hz by timer code
schedule_timeout trig a time for schedule()

update_curr called by :
        - reweight_entity
        - enqueue_entity
        - dequeue_entity
        - put_prev_entity               -> when schedule()
        - check_preempt_wakeup
        - ...

In practice, the virtual runtime of a task is its actual runtime normalized to the total
number of running tasks.

group tasks, it may be desirable to first provide fair CPU time to each user on the
system and then to each task belonging to a user.
        -> CONFIG_CGROUP_SCHED / CONFIG_RT_GROUP_SCHED / CONFIG_FAIR_GROUP_SCHED
        -> let the administrator create arbitrary groups of tasks
        -> entity_tick() use with group

An entity can be a single task or a groupd of task. When scheduling, the vruntime
is calculated:
        1. task in the group of tasks
        2. entity=group of tasks and parent of the curr task in the group of group of
           task
        3. ... until no more parent of the entity

Will not really change with group or not if correctly implemented

use task CPU load not priority

TODO:
- scheduler class
- rewrite task_tick, enqueu_tick, put_prev_task, pick_next_task, ...
- Update and select next task at update_curr

- Modify only the sched_entity

Attributes to update:
 	- avg running           -> in update_curr
 	- nr semaphores held	-> runtime __down() and __up() in sem.c
 	- nr of time blocked	-> runtime __down() and __up() in sem.c
 	- nr of time sleeping   -> runtime msleep and usleep in timer.c

QUESTION:
	- skip buddy -> set_skip_buddy() ->  yield_task_fair()
	- next buddy -> set_next_buddy()
	- last buddy -> set_last_buddy()

Balance:
--------

task load as the amount of time that the task was runnable during the time that
it was alive

https://lwn.net/Articles/80911/
https://lwn.net/Articles/639543/

- Folder kernel/sched
- Actually fair.c
- Replace fair.c -> myScheduler.c

1. define tick for load_balance()
2. define load_balance when one CPU is idle
3. define constant factor and selection of common load_balance and AI loadbalance in init/kConfig

rebalance_domains() or idle_balance() -> load_balance()
                        |
                        |_ called by schedule if CPU is about to become idle

_nohz_idle_balance or run_rebalance_domains
                        |
                        |_ triggered wen needed from te scheduler tick

- SB (Smart Balance) -> CONFIG_SCHED_SB

- each CPU has a base scheduling domain
- scheduling domain spans a number of CPUs -> "balance process load among these CPUs"
- scheduling domain can be child of another scheduling domain
- scheduling domain has one or more CPU groups
- group contains the physical CPUs or virtual CPUs or nodes to which to domain belongs
- group may be shared among CPU

- balancing within a sched domain occurs between groups
- each group is an entity with a load

scheduler_tick() core.c
        -> trigger_load_balance() fair.c if CONFIG_SMP
                if (time_after_eq(jiffies, rq->next_balance))
                        raise_softirq(SCHED_SOFTIRQ);
                nohz_balancer_kick()    -> for NO_HZ mode

when SOFTIRQ triggered by scheduler_tick() when balance_interval pass for the runqueue
        -> run_rebalance_domains() fair.c
                -> nohz_idle_balance() fair.c
                        -> rebalance_domains()
                -> update_blocked_averages() fair.c
                -> rebalance_domains() fair.c
                        -> for_each_domain(cpu, sd) check each schedule domain where the
                                                    current CPU is in from base
                                -> load_balance() fair.c()
                                -> sd->last_balance = jiffies;
                                -> interval = sd->balance_interval;
                                -> next_balance = sd->last_balance + interval;

load_balance()
        -> find_the_busiest_group()
        -> find_the_busiest_queue()
        -> QUESTION: Move task ???
                1. Determine how much task should be move
                        -> sysctl_sched_nr_migrate = 32; Number of tasks to
                                                         iterate in a single
                                                         balance run. Limited
                                                         because this is done
                                                         with IRQs disabled.
                2. detach_tasks() from busiest_rq
                        -> detach_task()
                3. attach_tasks() to new rq
                        -> attach_task()
                4. check if task with fixed affinity

QUESTION Update load:
1. update_load_avg() update task and cfs_rq load average
        -> __update_load_avg_se                 -> update load of schedul domain
                -> ___update_load_sum()
                -> ___update_load_avg()
        -> update_cfs_rq_load_avg()             -> update load of runqueue
                -> __update_load_avg_cfs_rq()
                        -> __update_load_sum()
                        -> __update_load_avg()
        -> propagate_entity_load_avg()
        -> update_tg_load_avg()

2. update_blocked_averages() do the same
        -> update_cfs_rq_load_avg()

NO_HZ -> Reducing scheduling-clock ticks

TODO:
- load_balance()
        -> watch among the group (each CPU)
        -> change find_the_busiest_group() and find_the_busiest_queue()
        -> calculate with they worst process if the process should be moved
           in the current CPU
        -> modify detach and attach tasks
- update_load_avg() update the different attributes used by the scheduler and migration
- u


Page reclaiming:
----------------

- Folder mm
- Actually vmscan.c
- Replace vmscan.c -> myScan.c

  Version 2                 Version 4
shrink_zone()          -> shrink_node()
shrink_list()          -> shrink_list()

shrink_cache()         -> shrink_node()
shrink_page_list()     -> refill_inactive_zone()


================================================================================
Configuration:

-> CONFIG_SCHEDSTATS

================================================================================
Module:
-------
https://www.tldp.org/LDP/lkmpg/2.6/html/lkmpg.html

List: lsmod
Load: insmod or modprobe
Unload: rmmod

Change kernel parameter with sysctl:
------------------------------------
sysctl: examining and changing kernel parameters at runtime.

-> list of all scheduler related sysctl variables



LFS:
----

--------------------------------------------------------------------------------
https://stackoverflow.com/questions/23358086/vnc-server-is-running-on-15901
http://mgalgs.github.io/2015/05/16/how-to-build-a-custom-linux-kernel-for-qemu-2015-edition.html

Install the modules
-------------------
make INSTALL_MOD_PATH=./ modules_install

if necessary: create boot directory

sudo make INSTALL_PATH=./boot install

Run Qemu
--------
qemu-system-x86_64 -kernel bzImage -initrd initrd.img-4.16.11 -m 512M

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Install Kernel:
===============

-> copy config:
        cp /boot/config-$(uname -r) .config
        make menuconfig
        make
        make modules_install
        make install
                copy kernel and .config file to the /boot folder
        update-initramfs        -c -k x.x.x
                indicate to use the new kernel x.x.x
        update_grub

NOTE: option -j n allow to split the compilation on n cores

linux distribution:
===================
        - slackware
        - fedora
        - ubuntu

QEMU:
=====
http://mgalgs.github.io/2015/05/16/how-to-build-a-custom-linux-kernel-for-qemu-2015-edition.html
https://nostillsearching.wordpress.com/2012/09/22/compiling-linux-kernel-and-running-it-using-qemu/

Run Kernel:
        mkinitramfs -o initrd.img-x.x.x
        qemu-system-i386 -kernel bzImage -initrd initrd.img-x.x.x -m 512M

        ------

        Ubuntu:
        mkinitramfs -o initrd.img-4.17.2
        qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage -initrd \
        initrd.igm-4.17.2 -m 512M -nographic -append 'console=ttyS0' -serial mon:stdio

        Fedora:
        dracut -o initramgs-4.17.2.img
        qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage -initrd \
        initramfs-4.17.2.img -m 512M -nographic -append 'console=ttyS0' -serial mon:stdio


        qemu-system-x86_64 -kernel arch/x86_64/boot/bzImage -initrd \
        initramfs-4.17.2.img -m 512M -nographic -append 'console=ttyS0' -serial mon:stdio

Run ISO:
        qemu-img create mydisk.img 10G
        qemu-system-x86_64 -boot d -cdrom image.iso -m 512 -hda mydisk.img
                                                        |          |
                                                   Use 512M RAM    |
                                                        Use image of 10G hard disk

add -smp n to give n core to the qemu system.

Create ISO:
===========
mkisofs -o destination-filename.iso /home/username/folder-name

Fedora:
=======
https://fedoraproject.org/wiki/How_to_use_qemu
https://fedoraproject.org/wiki/LiveOS_image
https://help.ubuntu.com/community/Installation/FromImgFiles/

Fedora:
        -> LiveOS
                -> squashfs.img

squashfs.img:
        -> LiveOS
                -> rootfs.img

rootfs.img:
        -> bin
        -> boot
        -> usr
        -> ...


        sudo mount -o loop /dev/sdc1 /mnt/iso
        sudo mount -o loop /mnt/iso/LiveOS/squashfs.img /mnt/LiveOS
        sudo mount /mnt/LiveOS/LiveOS/rootfs.img /mnt/FedRoot/

        chroot /mnt/FedRoot

        NOTE: The file must be mount in a way that they can be writable

0. Install on USB

        sudo dd if=Fedora-Workstation-Live-x86_64-28-1.1.iso of=/dev/sdc1 bs=4M && sync

        [dd] command copies a file, converting the format of the data in the
        process, according to the operands specified.

        [sync] synchronizes data on disk with memory

1. Run with Qemu

        qemu-img create mydisk.img 10G
        qemu-system-x86_64 -boot d -cdrom image.iso -m 512 -hda mydisk.img

        or for cdrom

        qemu -cdrom /dev/cdrom -hda mydisk.img -boot d -net nic -net user -m 196 -localtime

        or for usb

        sudo qemu-system-x86_64 -usb -usbdevice disk:/dev/sdc

        ------

        sudo qemu-system-x86_64 -cdrom Fedora-Workstation-Live-x86_64-28-1.1.iso \
        -hda fedora-disk.img -drive file=fedora-disk.img,format=raw -boot d \
        -net nic -net user -m 512 -localtime

Load a new OS in ISO
====================

        sudo mkdir /mnt/iso
        sudo mount -o loop my.iso /mnt/iso
        ls /mnt/iso/

        mv /path/to/kernel /mnt/iso/kernel

        chroot /path/to/distribution

        cp /boot/config-$(uname -r) .config
        make menuconfig
        make
        make modules_install
        make install
                copy kernel and .config file to the /boot folder
        update-initramfs        -c -k x.x.x
                indicate to use the new kernel x.x.x
        update_grub


https://www.google.com/search?client=ubuntu&channel=fs&q=linux+unpack+iso+on+usb&ie=utf-8&oe=utf-8
http://linuxforever.info/2017/06/16/write-image-iso-file-to-usb-with-command-line-in-linux-mint-ubuntu/


--------------------------------------------------------------------------------
Installation:
-------------
yum groupinstall "Development Tools" "Development Libraries"

0. CREATE FILE SYSTEM
        with cfdisk create a partition of type 83 (Linux)
        mkfs -v -t ext4 /dev/<device>

1. Create live USB
        - LiLi USB Creator
        - set persitent mode
        /!\ can only configurate Fedora v22

        or

        1. get livecd-iso-to-disk.sh
        2. make it executable
        3. install syslinux extlinux syslinux-common
        5. locate ldlinux.c32 libcom32.c32 libutil.c32
        4. copy
                /usr/lib/syslinux/modules/bios/ldlinux.c32 /usr/share/syslinux/ldlinux.c32
                /usr/lib/syslinux/modules/bios/libcom32.c32 /usr/share/syslinux/libcom32.c32
                /usr/lib/syslinux/modules/bios/libutil.c32 /usr/share/syslinux/libutil.c32
        5. umount device
        6. ./livecd-iso-to-disk --format --overlay-size-mb 16384 --home-size-mb 4096\
            --unencrypted-home --delete-home Fedora-Workstation-Live-x86_64-28-1.1.iso\
             /dev/<device>

sudo ./livecd-iso-to-disk --format --reset-mbr --overlayfs --overlay-size-mb 16384 --home-size-mb 8192 --unencrypted-home --delete-home --delete-home Fedora-Workstation-Live-x86_64-28-1.1.iso /dev/sdc1

2. Virtualize

        Run with Virtual Box, created with LiLi USB creator (Windows)
        - /path/to/usb/VirtualBox
        - Virtualize_This_Key.exe

        Run with quemu (Linux Distro)
        sudo qemu-system-x86_64 -enable-kvm -m 1024 -usb /dev/<device>

        NOTE: if impossible to run server:
                xhost +
                dbus-update-activation-environment --systemd DBUS_SESSION_BUS_ADDRESS DISPLAY XAUTHORITY

package:        sudo apt-get install virtinst \
                kvm \
                virt-manager \
                libvirt-daemon \
                python-libvirt \
                libvirt-bin \
                qemu \
                virt-viewer \
                bridge-utils \
                spice-client-gtk \
                virt-manager\
                libvirt-daemon\
                python-spice-client-gtk\
                qemu-kvm-spice\
                virt-viewer\
                spice-vdagent\
                qemu-utils\
                gir1.2-spice-client-gtk-3.0\
                gir1.2-spice-client-gtk-2.0\
                gir1.2-spice-client-glib-2.0

4. Install new kernel

        /!\ May be need chroot

        cp /boot/config-$(uname -r) .config
        make menuconfig
        make
        make modules
        make modules_install
        make install    -> copy kernel and .config file to the /boot folder

        update-initramfs        -c -k x.x.x
                indicate to use the new kernel x.x.x
        update_grub

5. ISO
        Create:
        genisoimage -o output_image.iso directory_name

        Decompress, required p7zip-full:
        7z x  disk.iso

6. IMG extract disk image ????
        Create:
        qemu-img create -f qcow2 test.img 2g

        Decompress:

5. Mount IMG Fedora
        LiveOS/squashfs.img
                -> /LiveOS/rootfs.img
                        -> /bin
                           /boot
                           /dev
                           ...

        sudo mkdir /mnt
        sudo mkdir /mnt/squashfs
        sudo mkdir /mnt/rootfs

        sudo mount -o loop,rw /media/<user>/<usb>/LiveOS/squashfs.img /mnt/squashfs
        sudo mount -o loop,rw /mnt/squashfs/LiveOS/ext3fs.img /mnt/rootfs/

        | At the end:
        | sudo umount /mnt/rootfs/
        | sudo umount /mnt/squashfs/

        /!\ .IMG and .ISO are read-only

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
http://people.redhat.com/harald/dracut.html#id535724
https://brennan.io/2017/03/08/sane-kernel-dev/
https://www.collabora.com/news-and-blog/blog/2017/01/16/setting-up-qemu-kvm-for-kernel-development/


------------------
https://www.kernel.org/doc/html/v4.17/admin-guide/initrd.html
https://superuser.com/questions/1190918/fastest-way-to-install-custom-kernel-in-virtual-machine
https://brennan.io/2017/03/08/sane-kernel-dev/
https://www.collabora.com/news-and-blog/blog/2017/01/16/setting-up-qemu-kvm-for-kernel-development/
https://blog.hartwork.org/posts/creating-fedora-chroots-on-debian-gentoo-easily/
https://github.com/dozzie/yumbootstrap
https://nmilosev.svbtle.com/quick-and-easy-fedora-minimal-chroot

Initramfs and initrd
--------------------
scheme for loading a temporary file system into memory in the boot process of
the Linux kernel.

Initrd          -> fixed-size block device, formated ext2
initramfs       -> cpio archive
                -> has no pivot_root
                -> set by CONFIG_BLK_DEV_INITRD

Create initrd           -> mkinitrd
Create initramfs        -> mkinitramfs or dracut

fakeroot

[FAILED] Failed to start Switch Root.
See 'systemctl status initrd-switch-root.service' for details.


Use Vido:
---------

[    1.033099] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
vido --kvm --kernel AI-linux/arch/x86_64/boot/bzImage -- sh

Other option:
------------

DEAD
qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage -m 512M -nographic -append 'console=ttyS0' -serial mon:stdio

FAIL AT SWITCH ROOT
qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage -initrd initramfs-4.17.2.img -m 512M -nographic -append 'console=ttyS0' -serial mon:stdio

FAIL AT SWITCH ROOT
qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage -initrd initramfs-4.17.2.img -append "root=UUID=7BA34C6E-F3C4-4B47-8CFA-A8FA99F56A" -m 512M -nographic -append 'console=ttyS0' -serial mon:stdio

qemu-system-x86_64 -kernel arch/x86_64/boot/bzImage -initrd initramfs-4.17.2.img -append "root=/dev/sda" -m 512M -nographic -append 'console=ttyS0' -serial mon:stdio


QUESTION: How to add rootfs ???
        https://www.ibm.com/developerworks/linux/library/l-boot-rootfs/
        -> debootstrap for debian, debootstrap is a tool which will install a Debian base system into a subdirectory
        -> yumbootstrap for fedora

Installation:
https://www.collabora.com/news-and-blog/blog/2017/01/16/setting-up-qemu-kvm-for-kernel-development/
https://olimex.wordpress.com/2014/07/21/how-to-create-bare-minimum-debian-wheezy-rootfs-from-scratch/

Run:
****
qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage \
-m 512M \
-hda qemu-image.img \
-append "root=/dev/sda rw" \
--enable-kvm \

qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage \
-m 512M \
-hda qemu-image.img \
-append "root=/dev/sda rw console=ttyS0" \
--enable-kvm \
-nographic \
-virtfs local,path=/home/nathan/share,mount_tag=host0,security_model=passthrough,id=host0

qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage \
-m 512M \
-hda qemu-image.img \
-append "root=/dev/sda rw console=ttyS0" \
--enable-kvm \
-nographic

sudo qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage \
-m 512M \
-drive format=raw,file=qemu-image.img \
-append "root=/dev/sda rw" \
--enable-kvm

Reset:
******
sudo umount $DIR
rmdir $DIR
rm $IMG

Image:
******
IMG=qemu-image.img
DIR=mount-point.dir
qemu-img create $IMG 2G
mkfs.ext4 $IMG
mkdir $DIR
sudo mount -o loop $IMG $DIR
sudo debootstrap --arch amd64 jessie $DIR
sudo umount $DIR
rmdir $DIR

Modify:
*******
chroot $DIR /bin/bash

Add user:
*********
useradd <new user>
passwd <user>

passwd root

Image read-only:
****************
- remount it when starting qemu
- -append "root=/dev/sda rw"

Use bash shell:
***************
nano /etc/shells
  -> write /bin/bash in first and /bin/sh in second
chsh -s /bin/bash then logout and login

Bash-completion:
****************
nano /etc/bash.bashrc

Add sudo:
*********
apt-get install sudo
sudo adduser <user> sudo or su -c "adduser <user> sudo"

to install
**********
sudo apt-get update
sudo apt-get upgrade
sudo apt-get install build-essential
sudo apt-get install python

Error message 'sudo: unable to resolve host <USER>':
****************************************************
https://askubuntu.com/questions/59458/error-message-sudo-unable-to-resolve-host-user

Shutdown and reboot
*******************
dpkg -S /sbin/shutdown
dpkg -S /sbin/reboot

Create share file between host and guest:
*****************************************

Configure the kernel with:  CONFIG_NET_9P=y
                            CONFIG_NET_9P_VIRTIO=y
                            CONFIG_NET_9P_DEBUG=y (Optional)
                            CONFIG_9P_FS=y
                            CONFIG_9P_FS_POSIX_ACL=y
                            CONFIG_PCI=y
                            CONFIG_VIRTIO_PCI=y

Add to qemu command: -virtfs local,path=/home/share,mount_tag=host0,
                              security_model=passthrough,id=host0

On host: mount -t 9p -o trans=virtio host0 /mnt -oversion=9p2000.L


Internet:
*********
on guest: ip link set eth0 up

activate ping: sysctl -w net.ipv4.ping_group_range='0 2147483647'

on host: brctl addbr br0
         brctl addif br0 eth0
         ip link set br0 up

add to qemu command:  -net nic,model=virtio \
                      -net bridge,br=br0

                      -net nic,model=virtio \
                      -net bridge,br=br0

qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage \
-hda qemu-image.img \
-append "root=/dev/sda rw console=ttyS0" \
--enable-kvm \
-nographic

NOTE: ERROR WITH DHCP
sudo apt-get install isc-dhcp-server

add the default pack address because use those of debootstrap

Dracut create initramfs with switch root:
-----------------------------------------
dracut -o initrd-4.17.2.img

Disk: /dev/sdb3 Linux LVM UUID 7BA34C6E-F3C4-4B47-8CFA-A8FA99F56AEA

dracut -o initrd-4.17.2.img root=UUID=7BA34C6E-F3C4-4B47-8CFA-A8FA99F56AEA

qemu-system-x86_64 \
-kernel AI-linux/arch/x86_64/boot/bzImage \
-initrd initramfs-4.17.2.img \
-m 512M  \
-append "root=UUID=7BA34C6E-F3C4-4B47-8CFA-A8FA99F56AEA"

qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage -initrd \
initramfs-4.17.2.img -m 512M -nographic -append 'console=ttyS0' -serial mon:stdio

qemu-system-x86_64 -kernel AI-linux/arch/x86_64/boot/bzImage \
-hda qemu-image.img \
-append "root=/dev/sdb" \
--enable-kvm \
--nographic
