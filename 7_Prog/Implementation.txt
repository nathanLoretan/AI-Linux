RQ INIT
=======

sched_init()                                            core.c
        init_synch_point()
        for_each_possible_cpu() ->
                init_cfs_rq()                           smart.c

Modified, Initialize the different factors and weights used by the AI and
          initialize the list that store the entity

CREATE NEW PROCESS
==================

kernel_thread()                                         fork.c
  do_fork()

do_fork()                                               fork.c
  _do_fork()
          copy_process()
                          dup_task_struct()       -> create the task
                          sched_fork()            core.c
          wake_up_new_task()                      core.c
                  activate_task()                 core.c

sched_fork()                                      core.c -> set rq of se
        __sched_fork()                            -> set sched_entity
        __set_task_cpu()
                set_task_rq()
        task_fork_smart()                         smart.c
                init_aistats()
                if curr -> update_curr
                place_entity()                    TODO
                normalize state

Modified, initialize the aistats structure of the new state, give the state
          of the parent process and normalize the state

ADD TASK IN QUEUE
=================

activate_task()                                                 core.c
        enqueue_task()
                enqueue_task_smart()                            smart.c
                        enqueue_entity()                        -> initialise vruntime of the process
                                if curr -> normalize
                                update_curr()
                                if !state_used -> add_aistats()
                                if !curr & !sleep -> normalize
                                if !curr -> __enqueue_entity()
                                se->on_rq = 1

Modified,

REMOVE TASK QUEUE
=================

deactivate_task()                                               core.c
        dequeue_task()
                dequeue_task_smart()                            smart.c
                        dequeue_entity()
                                update_curr()
                                if !state_used -> remove_aistats()
                                if !curr -> __dequeue_entity()
                                if !sleep -> Normalize state
                                se->on_rq = 0
                        set_next_buddy()

QUESTION: What call deactivate_task() ?

When migrating process:
detach_task()
        deactivate_task()

When scheduling, if !preempt && task not running (TASK_RUNNING = 0) and
                    !signal_pending_state(prev->state, prev)
__schedule()
        deactivate_task()

signal_pending_state(prev->state, prev)
        return 0 if state not (TASK_INTERRUPTIBLE | TASK_WAKEKILL)
        return 0 if TASK_INTERRUPTIBLE and signal not yet received

Modified,

UPDATE CURRENT ENTITY STATE AND RUNQUEUE STATE
==============================================

scheduler_tick()                                                core.c
        task_tick_smart()                                       smart.c
                entity_tick()
                        update_curr()
                                update_aistats()
                                update_state()
                                update_rewards()

Modified, update the state of the entity and the runqueue

SELECT NEW PROCESS
==================

resched_curr()  -> set TIF_NEED_RESCHED

schedule()                                                      core.c
        __schedule()
                pick_next_task()
                        pick_next_task_smart()                  smart.c
                                if curr->on_rq -> update_curr()
                                pick_next_entity()
                                        update_weights()
                                        update_next()

                		put_prev_entity()
                                        if still runnable
                                                update_curr()
                                                _enqueue_entity()

                                set_next_entity()
                                        _dequeue_entity()

Modified, Calculate the utility of the next task and select it to run next

SEMAPHORE and READ/WRITE SEM
============================

down()                                                          semaphore.c
        __down()
                __down_common()
                        __set_current_state(TASK_UNINTERRUPTIBLE)
                        list_add_tail(wait_list)
                        block_count++
                        schedule_timeout()                      timer.c
                                schedule()                      core.c
        lock_count++

NOTE: same for down_interruptible() down_killable() down_timeout()
NOTE: not for down_trylock() -> no wait

down_read()                                                     rwsem.c
        __down_read()
                __down_read_common()                            rwsem-spinlock.c
                        block_count++
                        list_add_tail(wait_list)
                        schedule()                              core.c
        lock_count++

NOTE: same for down_read_killable() down_write() down_write_killable()
NOTE: not for down_read_trylock() and down_write_trylock() -> no wait

up()                                                            semaphore.c
        __up()
                list_first_entry(wait_list)
                wake_up_process()                               core.c

up_read()                                                       rwsem.c
        __up_read()                                             rwsem-spinlock.c
                __rwsem_wake_one_writer()
                        list_entry()
                wake_up_process()

up_write()                                                      rwsem.c
        __up_write()                                            rwsem-spinlock.c
                __rwsem_do_wake()
                         list_entry()
                wkae_up_process()

Modified, add lock_count++ and block_count++

MUTEX
=====

NOTE: slowpath == sleep if fast path doesn't work

mutex_lock()                                                    mutex.c
        __mutex_lock_slowpath()
                __mutex_lock()
                        __mutex_lock_common()
                                list_add_tail(waiter.list)
                                block_count++
        lock_count++

NOTE: same for mutex_lock_interruptible() mutex_killable()
NOTE: not for mutex_trylock()

mutex_unlock()                                                    mutex.c
        __mutex_unlock_slowpath()
                list_first_entry()
                wake_up_add()
                wake_up_q()

Modified, add lock_count++ and block_count++

SPIN-LOCK
=========

spin_lock()                                                     spinlock.h
        raw_spin_lock()
                _raw_spin_lock()                                spinlock.c
                        __raw_spin_lock()                       spinlock_api_smp.h
                                do_raw_spin_lock()              spinlock_debug.c

NOTE: same for spin_lock_irqsave() spin_lock_bh() write_lock() read_lock()

spin_unlock()                                                   spinlock.h
        raw_spin_unlock()
                __raw_spin_unlock()                             spinlock_api_smp.h
                        do_raw_spin_unlock()                    spinlock_debug.c

NOTE: same for spin_unlock_irqrestore() spin_unlock_bh() write_unlock() read_unlock()

Modified, None

SLEEP
=====

udelay()        -> busy_wait_loop

usleep_range()                                          timer.c
        sleep_count++
        __set_current_state(TASK_UNINTERRUPTIBLE)
        schedule_hrtimeout_range()                      hrtimer.c
                ...
                        enqueue_hrtimer()
                                timerqueue_add()        timerqueue.c
                schedule()


        remove_hrtimer                                  hrtimer.c
                timerqueue_del                          timerqueue.c

msleep()                                                timer.c
        sleep_count++
        schedule_timeout_uninterruptible()
                __set_current_state(TASK_UNINTERRUPTIBLE)
        	schedule_timeout(timeout)

msleep_interruptible()                                  timer.c
        sleep_count++
        schedule_timeout_interruptible()
                __set_current_state(TASK_INTERRUPTIBLE)
                schedule_timeout(timeout)

schedule_timeout() -> callback function process_timeout
         process_timeout()                              timer.c
                wake_up_process()                       core.c

Modified, add sleep_count++

WAKE UP
=======

wake_up_process()                                               core.c
        try_to_wake_up()
                ttwu_remote() if p->on_rq
                        ttwu_do_wakeup()
                                p->state = TASK_RUNNING

                ttwu_queue()
                        ttwu_do_activate()
                                ttwu_activate()
                                        activate_task()
                                ttwu_do_wakeup()
                                        p->state = TASK_RUNNING

Modified, None

KILL
====

do_exit()                                               exit.c
        set_current_state(TASK_UNINTERRUPTIBLE)
        schedule()
                __schedule()
                        deactivate_task()

do_group_exit()
        do_exit()

Modified, None

YIELD
=====

yield()                                                 core.c
        do_sched_yield()
                yield_task_fair()                       smart.c
                        update_curr()
                        set_skip_buddy()
                schedule()                              core.c

yield_to()                                              core.c
        yield_to_task_fair()                            smart.c
                yield_task_fair()

Modified, None

-------

put_prev_task_fair()                                    smart.c
        put_prev_entity()

set_curr_task_fair()                                    smart.c
        set_next_entity()

Modified, None

-------

static void remove_aistats(struct cfs_rq *cfs_rq, struct sched_entity *old)
static void add_aistats(struct cfs_rq *cfs_rq, struct sched_entity *new)

TODO:   . Initialize AI in runqueue                    -> init_cfs_rq()                OK
        . Initialize sched_entity in new process       -> task_fork_smart()            OK
        . Update environement when deleting a task     -> dequeue_entity()             OK
        . Update environement when adding a task       -> enqueue_entity()             OK
        . Change group                                                                 OK
                -> switched_from() & task_change_group()
                => detach_task_cfs_rq & attach_task_cfs_rq
        . Calculate the utility of the next task       -> pick_next_task_smart()       OK
        . Update the environment                       -> update_curr()                OK
                - creating      OK
                - deleting      OK
                - sleeping      OK
                - blocking      OK
                - scheduling    OK
                - wake-up       OK
        . Set attributes with macro:
                scheduled_count                         -> smart.c      OK
                        pick_next_task_smart()

                runtime_sum                             -> smart.c      OK
                        update_aistats()

                state                                   -> smart.c      OK
                        update_state()
                        enqueue_entity()
                        dequeue_entity()
                        task_fork_smart

                sleep_count                             -> timer.c      OK
                        usleep_range()
                        msleep()
                        msleep_interruptible()

                lock_count
                        down()                          -> semaphore.c  OK
                        down_interruptible()
                        down_killable()
                        down_trylock()
                        down_timeout()

                        down_read()                     -> rwsem.c      OK
                        down_read_killable()
                        down_read_trylock()

                        down_write()                    -> rwsem.c      OK
                        down_write_killable()
                        down_write_trylock()

                        mutex_lock()                    -> mutex.c      OK
                        mutex_lock_interruptible()
                        mutex_lock_killable()
                        mutex_trylock()

                block_count, only the added to the wait list            OK
                        __down_common()                 -> semaphore.c
                        __down_read_common()            -> rwsem-spinlock.c
                        __down_write_common()
                        __mutex_lock_common()           -> mutex.c

        . Average, Calcul, Fixed Point, Overflow                        OK

                update_rewards()        OK
                update_aistats()        OK
                update_weights()        OK
                update_next()           OK

                add(a, b, ta, tb) 	 a + b
                sub(a, b, t1, t2)  	 a - b
                mul(a, b, t1, t2)	(a * b) >> Q
                div(a, b, t1, t2)	(a << Q) / b

                Type:
                u32     ->      0 to 4,294,967,295
                s32     ->      -2,147,483,648 to 2,147,483,647
                u64     ->      0 to 18,446,744e12
                s64     ->      -9,223,372e12 to 9,223,372e12

                What to scale:
                x avg_runtime   x alpha         x w_load        x rewards
                x avg_block     x gamma         x w_avg_block   x ut
                x avg_sleep     x q_value       x w_avg_sleep   x ut_sum
                x avg_lock      x old_q_value   x w_avg_lock

                Type definition: all s64
                - alpha                         - scheduled_count
                - gamma                         - state
                - w_load                        - old_state
                - w_avg_block
                - w_avg_sleep                   - avg_runtime
                - w_avg_lock                    - runtime_sum
                - state                         - avg_block
                - q_value                       - block_count
                - old_q_value                   - avg_sleep
                - ut_sum                        - sleep_count
                - update                        - avg_lock
                - rewards                       - lock_count
                - min_start_state               - di
                - min_state                     - ut

                overflow:
                        scheduled_count
                        runtime_sum
                        block_count
                        sleep_count
                        lock_count

        . place_entity()                        OK
        . synchronization_point
                TODO: evaluate the weight and stop learning

        . Remove everythings with vruntime ...

        . Set kconfig:
                CONFIG_SCHED_SFS
                CONFIG_SCHED_SFS_SYNCH
                CONFIG_SCHED_SFS_FIXP_SHIFT
                CONFIG_SCHED_SFS_ALPHA
                CONFIG_SCHED_SFS_GAMMA
                CONFIG_SCHED_SFS_W_AGV_LOAD
                CONFIG_SCHED_SFS_W_AGV_BLOCK
                CONFIG_SCHED_SFS_W_AGV_SLEEP
                CONFIG_SCHED_SFS_W_AGV_SEM

                NOTE: the constant should already be scaled to the fixedpoint
